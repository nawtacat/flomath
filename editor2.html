<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Shorts Editor</title>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --accent: #007acc;
            --text: #cccccc;
            --border: #3e3e42;
        }

        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative; /* For drag-drop overlay */
        }

        /* Layout */
        header {
            height: 50px;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
        }

        h1 { font-size: 18px; margin: 0; }

        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 10px;
            overflow-y: auto;
        }

        .viewport {
            flex: 1;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        .timeline-container {
            height: 200px;
            background-color: var(--bg-panel);
            border-top: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        /* Canvas */
        canvas {
            background-color: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-height: 90%;
            max-width: 90%;
        }

        /* Controls */
        button {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 5px;
        }

        button:hover { opacity: 0.9; }
        button.secondary { background-color: #444; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .control-group {
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #888;
        }

        input[type="text"], input[type="number"], input[type="file"] {
            width: 100%;
            background: #333;
            border: 1px solid var(--border);
            color: white;
            padding: 5px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        .property-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        .property-row input { width: 60px; margin-bottom: 0; }
        .property-row span { font-size: 12px; width: 60px;}

        /* Timeline */
        .timeline-controls {
            height: 40px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 10px;
        }

        .timeline-tracks {
            flex: 1;
            position: relative;
            overflow-x: auto;
            overflow-y: auto;
            background: #1e1e1e;
        }

        .scrubber-track {
            height: 20px;
            background: #333;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            border-bottom: 1px solid #555;
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: red;
            z-index: 20;
            pointer-events: none;
        }

        .layer-block-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 15px;
            cursor: ew-resize;
            z-index: 20; /* Higher than text */
            background: rgba(255,255,255,0.1);
        }
        .layer-block-handle:hover {
            background: rgba(255, 255, 0, 0.5);
        }
        .layer-block-handle.left {
            left: 0;
            border-radius: 4px 0 0 4px;
        }
        .layer-block-handle.right {
            right: 0;
            border-radius: 0 4px 4px 0;
        }

        .layer-block.dragging-source {
            opacity: 0.3;
        }

        .layer-track {
            height: 30px;
            border-bottom: 1px solid #333;
            position: relative;
            margin-top: 2px;
        }

        .layer-track.empty {
            border-style: dashed;
            border-color: rgba(255, 255, 255, 0.25);
            background: rgba(255, 255, 255, 0.02);
        }

        .layer-track.placeholder {
            height: 40px;
            border: 1px dashed #555;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            letter-spacing: 0.05em;
            font-size: 11px;
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.05);
        }

        .layer-block {
            position: absolute;
            height: 100%;
            background: var(--accent);
            opacity: 0.7;
            border-radius: 4px;
            padding-left: 5px;
            font-size: 12px;
            line-height: 30px;
            overflow: visible;
            white-space: nowrap;
            cursor: pointer;
            border: 1px solid transparent;
        }

        .layer-block.selected {
            border-color: white;
            opacity: 1;
        }

        .keyframe-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            background: yellow;
            border-radius: 50%;
            top: 11px;
            transform: translateX(-50%);
            pointer-events: none;
        }

        /* Export Overlay */
        #export-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-direction: column;
        }

        #drop-indicator {
            position: absolute;
            width: 100%;
            height: 2px;
            background: yellow;
            z-index: 999;
            display: none;
            pointer-events: none;
        }


        /* Drag & Drop Overlay */
        #drag-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 122, 204, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: none;
            border: 5px dashed white;
            box-sizing: border-box;
        }
        #drag-overlay h2 { color: white; font-size: 3em; text-shadow: 2px 2px 4px #000; }

    </style>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>
</head>
<body>

<header>
    <div style="display:flex; align-items:center; gap:10px;">
        <h1>Gemini Shorts Editor</h1>
        <span style="font-size:12px; color:#888;">1080x1920</span>
    </div>
    <div>
        <button id="btn-export">Export Video</button>
    </div>
</header>

<div class="main-container">
    <div class="sidebar">
        <div class="control-group">
            <label>Add Media</label>
            <button class="secondary" onclick="addTextLayer()">+ Text</button>
            <button class="secondary" onclick="document.getElementById('img-upload').click()">+ Image</button>
            <button class="secondary" onclick="document.getElementById('vid-upload').click()">+ Video</button>
            <input type="file" id="img-upload" accept="image/*" style="display:none" onchange="handleImageUpload(this)">
            <input type="file" id="vid-upload" accept="video/*" style="display:none" onchange="handleVideoUpload(this)">
        </div>

        <div class="control-group">
            <label>Global Zoom (Keyframable)</label>
            <div class="property-row">
                <span>Zoom</span>
                <input type="number" step="0.1" id="global-prop-scale" onchange="updateCurrentGlobalTransform('scale', this.value)">
                <button class="secondary" style="padding:2px 6px;" onclick="addGlobalKeyframe()">◆</button>
            </div>
            <div class="property-row">
                <span>Pan X</span>
                <input type="number" id="global-prop-x" onchange="updateCurrentGlobalTransform('x', this.value)">
                <button class="secondary" style="padding:2px 6px;" onclick="addGlobalKeyframe()">◆</button>
            </div>
            <div class="property-row">
                <span>Pan Y</span>
                <input type="number" id="global-prop-y" onchange="updateCurrentGlobalTransform('y', this.value)">
                <button class="secondary" style="padding:2px 6px;" onclick="addGlobalKeyframe()">◆</button>
            </div>
            <div id="global-zoom-controls" style="margin-top:10px; border-top:1px solid #444; padding-top:10px;">
                <label>Motion Controls</label>
                <div class="property-row" style="margin-bottom: 10px;">
                    <span style="width: 90px;">Duration (s)</span>
                    <input type="text" id="global-duration" oninput="updateGlobalMotion('duration', this.value)" placeholder="auto" style="margin-bottom: 0;">
                </div>
                <div class="property-row" style="margin-bottom: 10px;">
                    <span style="width: 110px;" title="Controls how often the zoom updates. Lower values look more stepped; higher values look smoother.">Zoom Motion FPS</span>
                    <input type="number" id="global-fps" oninput="updateGlobalMotion('aestheticFps', this.value)" value="60" style="margin-bottom: 0;">
                </div>
                <div class="property-row" style="margin-bottom: 10px;">
                    <span style="width: 90px;">Speed Curve</span>
                    <select id="global-easing" onchange="updateGlobalMotion('easing', this.value)" style="flex:1; background:#333; color:white; border:1px solid var(--border); padding:5px;">
                        <option value="ease-out">Ease Out (Fast start)</option>
                        <option value="ease-in">Ease In (Slow start)</option>
                        <option value="ease-in-out">Ease In-Out</option>
                        <option value="linear">Linear (Constant)</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="control-group" id="properties-panel" style="display:none;">
            <label>Properties (Keyframable)</label>
            <div style="margin-bottom:10px; font-weight:bold;" id="selected-layer-name">Layer</div>
            
            <div class="property-row">
                <span>X Position</span>
                <input type="number" id="prop-x" onchange="updateProperty('x', this.value)">
                <button class="secondary" style="padding:2px 6px;" onclick="addKeyframe('x')">◆</button>
            </div>
            <div class="property-row">
                <span>Y Position</span>
                <input type="number" id="prop-y" onchange="updateProperty('y', this.value)">
                <button class="secondary" style="padding:2px 6px;" onclick="addKeyframe('y')">◆</button>
            </div>
            <div class="property-row">
                <span>Scale</span>
                <input type="number" step="0.1" id="prop-scale" onchange="updateProperty('scale', this.value)">
                <button class="secondary" style="padding:2px 6px;" onclick="addKeyframe('scale')">◆</button>
            </div>
            <div class="property-row">
                <span>Rotation</span>
                <input type="number" id="prop-rotation" onchange="updateProperty('rotation', this.value)">
                <button class="secondary" style="padding:2px 6px;" onclick="addKeyframe('rotation')">◆</button>
            </div>
            <div class="property-row">
                <span>Opacity</span>
                <input type="number" step="0.1" max="1" min="0" id="prop-opacity" onchange="updateProperty('opacity', this.value)">
                <button class="secondary" style="padding:2px 6px;" onclick="addKeyframe('opacity')">◆</button>
            </div>
            
            <div id="text-props" style="display:none; margin-top:10px; border-top:1px solid #444; padding-top:10px;">
                <label>Text Content</label>
                <input type="text" id="prop-text" oninput="updateText(this.value)">
                <label>Color</label>
                <input type="color" id="prop-color" onchange="updateColor(this.value)" style="width:100%">
            </div>

            <button class="secondary" style="width:100%; margin-top:10px; background:#a33;" onclick="deleteSelectedLayer()">Delete Layer</button>
            <button class="secondary" style="width:100%; margin-top:5px;" onclick="splitSelectedLayer()">Split Layer at Playhead</button>

            <div style="margin-top:10px; border-top:1px solid #444; padding-top:10px;">
                <label>Looping Animation</label>
                <select id="prop-loop" onchange="updateLoopingAnimation(this.value)" style="width:100%; background:#333; color:white; border:1px solid var(--border); padding:5px; margin-top:5px;">
                    <option value="none">None</option>
                    <option value="pulse">Pulse</option>
                    <option value="spin">Spin</option>
                    <option value="float">Float</option>
                </select>
            </div>
        </div>
    </div>

    <div class="viewport">
        <!-- 1080x1920 scaled down to fit -->
        <canvas id="editor-canvas" width="1080" height="1920"></canvas>
    </div>
</div>

<div class="timeline-container">
    <div class="timeline-controls">
        <button id="btn-play">Play</button>
        <button class="secondary" id="btn-stop">Stop</button>
        <button class="secondary" onclick="addUniversalKeyframe()" title="Add Keyframe for selected layer or global zoom" style="margin-left: 10px;">◆ Add Keyframe</button>
        <span id="time-display" style="margin-left:auto; font-family:monospace;">00:00.00</span>
    </div>
    <div class="timeline-tracks" id="timeline-tracks">
        <div id="drop-indicator"></div>
        <div id="global-zoom-track" class="layer-track" style="height:20px; background: #2a2a2d; border-bottom: 1px solid #555;"></div>
        <div class="scrubber-track" id="scrubber"></div>
        <div class="playhead" id="playhead"></div>
        <!-- Tracks go here -->
    </div>
</div>

<div id="export-overlay">
    <h2>Rendering Video...</h2>
    <p>Please wait, do not close this tab.</p>
    <div style="width: 300px; height: 10px; background: #333; border-radius: 5px; overflow: hidden;">
        <div id="export-progress" style="width: 0%; height: 100%; background: var(--accent);"></div>
    </div>
</div>

<div id="drag-overlay">
    <h2>Drop files to upload</h2>
</div>

<script>
    // --- Constants & State ---
    const CANVAS_WIDTH = 1080;
    const CANVAS_HEIGHT = 1920;
    const FPS = 60;
    const PIXELS_PER_SECOND = 50; // Timeline zoom
    
    const canvas = document.getElementById('editor-canvas');
    const zoomClickSound = new Audio('https://flomath.space/audio/click.mp3');
    zoomClickSound.preload = 'auto';

    const ctx = canvas.getContext('2d');
    const bufferCanvas = document.createElement('canvas');
    bufferCanvas.width = CANVAS_WIDTH;
    bufferCanvas.height = CANVAS_HEIGHT;
    const bufferCtx = bufferCanvas.getContext('2d');

    
    let state = {
        currentTime: 0, // in seconds
        duration: 10, // default 10 seconds
        isPlaying: false,
        layers: [],
        selectedLayerId: null,
        nextId: 1,
        layerSlots: [],
        nextSlotId: 1,
        globalTransform: {
            keyframes: [], // { time, scale, x, y }
            duration: 'auto', // 'auto' or seconds
            easing: 'ease-out',
            aestheticFps: 60
        },
        currentGlobalTransform: {
            scale: 1,
            x: CANVAS_WIDTH / 2,
            y: CANVAS_HEIGHT / 2
        },
        lastGlobalFinalProgress: undefined,
    };

    let animationFrameId;
    let lastTime = 0;
    let dragState = {
        active: false,
        type: null, // 'resize-timeline', 'move-timeline', 'canvas-drag', 'canvas-scale', 'canvas-rotate'
        layerId: null,
        handle: null, // 'left' or 'right'
        startX: 0,
        startY: 0,
        initialStartTime: 0,
        initialDuration: 0,
        initialX: 0,
        initialY: 0,
        initialScale: 1,
        initialDist: 0,
        initialAngle: 0,
        initialRotation: 0,
        isReordering: false,
        sourceElement: null,
        sourceSlotIndex: -1,
        targetSlotIndex: -1,
        timelineContainer: null,
        sourceSlotId: null
    };

    const GLOBAL_EASING_FUNCTIONS = {
        'linear': (t) => t,
        'ease-in': (t) => Math.pow(t, 5),
        'ease-out': (t) => 1 - Math.pow(1 - t, 5),
        'ease-in-out': (t) => t < 0.5
            ? 16 * Math.pow(t, 5)
            : 1 - Math.pow(-2 * t + 2, 5) / 2
    };


    // --- Classes ---

    class Layer {
        constructor(type, name, content) {
            this.id = state.nextId++;
            this.type = type; // 'text', 'image', 'video'
            this.name = name;
            this.content = content; // Text string or Image/Video Element
            this.startTime = 0;
            this.duration = 5;
            this.width = 0;
            this.height = 0;
            
            // Initial Transform
            this.x = CANVAS_WIDTH / 2;
            this.y = CANVAS_HEIGHT / 2;
            this.scale = 1;
            this.rotation = 0;
            this.opacity = 1;
            this.color = '#ffffff'; // for text
            this.loopingAnimation = 'none';
            this.slotId = null;

            // Keyframes: { property: [ {time, value}, ... ] }
            this.keyframes = {
                x: [], y: [], scale: [], rotation: [], opacity: []
            };

            this.updateDimensions();
        }

        updateDimensions() {
            if (this.type === 'text') {
                ctx.font = 'bold 100px Arial';
                const metrics = ctx.measureText(this.content);
                this.width = metrics.width;
                this.height = 100; // Approx height
            } else if (this.type === 'image' || this.type === 'video') {
                if (this.content.width || this.content.videoWidth) {
                    this.width = this.content.width || this.content.videoWidth;
                    this.height = this.content.height || this.content.videoHeight;
                }
            }
        }

        getValue(prop, time) {
            const kfs = this.keyframes[prop];
            if (!kfs || kfs.length === 0) return this[prop];

            // Sort keyframes by time just in case
            kfs.sort((a, b) => a.time - b.time);

            // If time is before first keyframe
            if (time <= kfs[0].time) return kfs[0].value;
            // If time is after last keyframe
            if (time >= kfs[kfs.length - 1].time) return kfs[kfs.length - 1].value;

            // Interpolate
            for (let i = 0; i < kfs.length - 1; i++) {
                if (time >= kfs[i].time && time < kfs[i+1].time) {
                    const t1 = kfs[i].time;
                    const t2 = kfs[i+1].time;
                    const v1 = kfs[i].value;
                    const v2 = kfs[i+1].value;
                    const progress = (time - t1) / (t2 - t1);
                    return v1 + (v2 - v1) * progress; // Linear interpolation
                }
            }
            return this[prop];
        }

        addKeyframe(prop, time, value) {
            // Remove existing keyframe at exact same time
            this.keyframes[prop] = this.keyframes[prop].filter(k => Math.abs(k.time - time) > 0.01);
            this.keyframes[prop].push({ time, value: parseFloat(value) });
            this.keyframes[prop].sort((a, b) => a.time - b.time);
            renderTimeline(); // Update UI markers
        }

        updateOrAddKeyframe(prop, time, value) {
            const kfs = this.keyframes[prop];
            const existing = kfs.find(k => Math.abs(k.time - time) < 0.01);
            if (existing) {
                existing.value = parseFloat(value);
            } else {
                kfs.push({ time: time, value: parseFloat(value) });
                kfs.sort((a, b) => a.time - b.time);
            }
        }

        clone() {
            const newLayer = new Layer(this.type, this.name, this.content);
            // Deep copy serializable properties
            const serialized = JSON.parse(JSON.stringify(this));
            Object.assign(newLayer, serialized);
            
            // Manually copy non-serializable content
            newLayer.content = this.content;
            newLayer.id = state.nextId++; // Ensure a new unique ID
            newLayer.slotId = this.slotId;
            return newLayer;
        }
    }

    // --- Core Engine ---

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        renderTimeline();
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
        updateGlobalMotionControlsUI();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function resizeCanvas() {
        // Keep canvas internal resolution 1080x1920, but scale via CSS to fit viewport
        const viewport = document.querySelector('.viewport');
        const aspect = CANVAS_WIDTH / CANVAS_HEIGHT;
        const vH = viewport.clientHeight * 0.9;
        const vW = vH * aspect;
        
        canvas.style.width = `${vW}px`;
        canvas.style.height = `${vH}px`;
    }

    function gameLoop(timestamp) {
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        if (state.isPlaying) {
            state.currentTime += dt;
            if (state.currentTime >= state.duration) {
                state.currentTime = 0;
                state.isPlaying = false;
                updatePlayButton();
            }
            updateTimelineUI(); // Update inputs as values animate
            updateAllPanels();
        }

        renderCanvas();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function renderCanvas() {
        rebuildSlotAssignments();
        // Clear buffer canvas
        bufferCtx.fillStyle = '#000';
        bufferCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw Layers to buffer
        const layersToRender = [...state.layers].sort((a, b) => {
            const slotA = getSlotIndexById(a.slotId);
            const slotB = getSlotIndexById(b.slotId);
            if (slotA !== slotB) return slotA - slotB;
            return a.id - b.id;
        });

        layersToRender.forEach(layer => {
            // Check visibility based on time
            if (state.currentTime < layer.startTime || state.currentTime > layer.startTime + layer.duration) return;

            
            const x = layer.getValue('x', state.currentTime);
            let y = layer.getValue('y', state.currentTime);
            let scale = layer.getValue('scale', state.currentTime);
            let rotation = layer.getValue('rotation', state.currentTime);
            const opacity = layer.getValue('opacity', state.currentTime);

            // Apply looping animations on top of keyframed values
            if (layer.loopingAnimation && layer.loopingAnimation !== 'none') {
                switch(layer.loopingAnimation) {
                    case 'pulse':
                        // Pulse 5% of size, twice per second
                        scale *= (1 + Math.sin(state.currentTime * Math.PI * 4) * 0.05);
                        break;
                    case 'spin':
                        // Spin 90 degrees per second
                        rotation += (state.currentTime * 90);
                        break;
                    case 'float':
                        // Float up and down by 20px, once every 2 seconds
                        y += (Math.sin(state.currentTime * Math.PI) * 20);
                        break;
                }
            }

            bufferCtx.save();
            bufferCtx.globalAlpha = opacity;
            bufferCtx.translate(x, y);
            bufferCtx.rotate(rotation * Math.PI / 180);
            bufferCtx.scale(scale, scale);

            if (layer.type === 'text') {
                bufferCtx.font = 'bold 100px Arial';
                bufferCtx.fillStyle = layer.color;
                bufferCtx.textAlign = 'center';
                bufferCtx.textBaseline = 'middle';
                bufferCtx.fillText(layer.content, 0, 0);
            } else if (layer.type === 'image') {
                const img = layer.content;
                bufferCtx.drawImage(img, -img.width/2, -img.height/2);
            } else if (layer.type === 'video') {
                const vid = layer.content;
                // Sync video time
                if (!vid.paused && !state.isPlaying) vid.pause();
                if (state.isPlaying && vid.paused) vid.play();
                
                // Seek if drifted
                const vidTime = state.currentTime - layer.startTime;
                if (Math.abs(vid.currentTime - vidTime) > 0.3) {
                    vid.currentTime = vidTime;
                }
                
                bufferCtx.drawImage(vid, -vid.videoWidth/2, -vid.videoHeight/2);
            }

            // Selection outline
            if (state.selectedLayerId === layer.id) {
                bufferCtx.strokeStyle = '#007acc';
                bufferCtx.lineWidth = 5;
                bufferCtx.beginPath();
                const w = layer.width || 100;
                const h = layer.height || 100;
                bufferCtx.rect(-w/2, -h/2, w, h);
                bufferCtx.stroke();

                // Draw Resize Handles (Corners)
                bufferCtx.fillStyle = 'white';
                const handleSize = 20 / scale; // Keep handles consistent visual size
                const corners = [
                    {x: -w/2, y: -h/2}, {x: w/2, y: -h/2},
                    {x: w/2, y: h/2}, {x: -w/2, y: h/2}
                ];
                corners.forEach(c => {
                    bufferCtx.fillRect(c.x - handleSize/2, c.y - handleSize/2, handleSize, handleSize);
                });

                // Rotation Handle (Top)
                bufferCtx.beginPath();
                bufferCtx.moveTo(0, -h/2);
                bufferCtx.lineTo(0, -h/2 - 50/scale);
                bufferCtx.stroke();
                bufferCtx.beginPath();
                bufferCtx.arc(0, -h/2 - 50/scale, 10/scale, 0, Math.PI*2);
                bufferCtx.fill();
            }

            bufferCtx.restore();
        });

        // --- NEW PART ---
        // Get global transform and draw buffer to main canvas
        const transform = getGlobalTransform(state.currentTime);

        // --- AUDIO CLICK LOGIC ---
        if (transform.finalProgress !== undefined && transform.finalProgress !== state.lastGlobalFinalProgress) {
            if (state.isPlaying) { // Only play during playback
                zoomClickSound.currentTime = 0;
                zoomClickSound.play().catch(e => {}); // Autoplay can be blocked by browser
            }
        }
        state.lastGlobalFinalProgress = transform.finalProgress;


        // Clear main canvas
        ctx.fillStyle = '#111'; // Match viewport background
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Apply global transform
        ctx.save();
        // Center the view on the transformed point, and scale.
        ctx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
        ctx.scale(transform.scale, transform.scale);
        ctx.translate(-transform.x, -transform.y);

        // Draw the pre-composited frame from the buffer
        ctx.drawImage(bufferCanvas, 0, 0);

        ctx.restore();
    }

    function updateAllPanels() {
        updatePropertiesPanel();
        updateGlobalTransformPanel();
    }

    function createLayerSlot(name = null, insertIndex = state.layerSlots.length) {
        const slot = {
            id: state.nextSlotId++,
            name: name || `Layer ${state.layerSlots.length + 1}`,
            itemIds: []
        };
        state.layerSlots.splice(insertIndex, 0, slot);
        return slot;
    }

    function ensureDefaultLayerSlot() {
        if (state.layerSlots.length === 0) {
            return createLayerSlot('Layer 1', 0);
        }
        return state.layerSlots[state.layerSlots.length - 1];
    }

    function getSlotById(slotId) {
        return state.layerSlots.find(slot => slot.id === slotId);
    }

    function getSlotIndexById(slotId) {
        const idx = state.layerSlots.findIndex(slot => slot.id === slotId);
        return idx === -1 ? 0 : idx;
    }

    function rebuildSlotAssignments() {
        ensureDefaultLayerSlot();
        state.layerSlots.forEach(slot => slot.itemIds = []);
        state.layers.forEach(layer => {
            if (!layer.slotId || !getSlotById(layer.slotId)) {
                const defaultSlot = ensureDefaultLayerSlot();
                layer.slotId = defaultSlot.id;
            }
            const slot = getSlotById(layer.slotId);
            if (slot && !slot.itemIds.includes(layer.id)) {
                slot.itemIds.push(layer.id);
            }
        });
    }

    function assignLayerToSlot(layer, slotId) {
        if (!layer) return;
        let slot = getSlotById(slotId);
        if (!slot) {
            slot = ensureDefaultLayerSlot();
        }
        state.layerSlots.forEach(s => {
            s.itemIds = s.itemIds.filter(id => id !== layer.id);
        });
        layer.slotId = slot.id;
        slot.itemIds.push(layer.id);
    }

    function placeLayerOnTopSlot(layer) {
        const topSlot = ensureDefaultLayerSlot();
        assignLayerToSlot(layer, topSlot.id);
    }

    // --- Layer Management ---

    function addTextLayer() {
        const l = new Layer('text', 'Text Layer', 'HELLO');
        state.layers.push(l);
        placeLayerOnTopSlot(l);
        selectLayer(l.id);
        renderTimeline();
    }

    function addMediaFile(file) {
        const fileType = file.type.split('/')[0];
        if (fileType === 'image') {
            const img = new Image();
            img.onload = () => {
                const l = new Layer('image', file.name, img);
                state.layers.push(l);
                placeLayerOnTopSlot(l);
                selectLayer(l.id);
                renderTimeline();
            };
            img.src = URL.createObjectURL(file);
        } else if (fileType === 'video') {
            const vid = document.createElement('video');
            vid.src = URL.createObjectURL(file);
            vid.muted = true;
            vid.onloadedmetadata = () => {
                const l = new Layer('video', file.name, vid);
                l.duration = vid.duration;
                state.layers.push(l);
                placeLayerOnTopSlot(l);
                selectLayer(l.id);
                renderTimeline();
            };
        }
    }

    function handleImageUpload(input) {
        if (input.files[0]) addMediaFile(input.files[0]);
        input.value = ''; // Allow re-uploading the same file
    }

    function handleVideoUpload(input) {
        if (input.files[0]) addMediaFile(input.files[0]);
        input.value = '';
    }

    function selectLayer(id) {
        state.selectedLayerId = id;
        const layer = state.layers.find(l => l.id === id);
        
        const panel = document.getElementById('properties-panel');
        const textProps = document.getElementById('text-props');
        
        if (layer) {
            panel.style.display = 'block';
            document.getElementById('selected-layer-name').innerText = layer.name;
            
            if (layer.type === 'text') {
                textProps.style.display = 'block';
                document.getElementById('prop-text').value = layer.content;
                document.getElementById('prop-color').value = layer.color;
            } else {
                textProps.style.display = 'none';
            }
            document.getElementById('prop-loop').value = layer.loopingAnimation || 'none';
            updatePropertiesPanel();
        } else {
            panel.style.display = 'none';
        }
        renderTimeline();
    }

    function deleteSelectedLayer() {
        if (!state.selectedLayerId) return;
        state.layers = state.layers.filter(l => l.id !== state.selectedLayerId);
        state.selectedLayerId = null;
        selectLayer(null);
        renderTimeline();
    }

    function splitSelectedLayer() {
        if (!state.selectedLayerId) return;
        const originalLayer = state.layers.find(l => l.id === state.selectedLayerId);
        if (!originalLayer) return;

        const cutTime = state.currentTime;
        // Check if cut is valid (within the layer's duration, not at the very start/end)
        if (cutTime <= originalLayer.startTime + 0.01 || cutTime >= originalLayer.startTime + originalLayer.duration - 0.01) {
            alert('Playhead must be inside the selected layer to split.');
            return;
        }

        const endOfOriginal = originalLayer.startTime + originalLayer.duration;

        // Create the new (right-hand side) layer from a clone
        const newLayer = originalLayer.clone();
        newLayer.startTime = cutTime;
        newLayer.duration = endOfOriginal - cutTime;
        newLayer.name = originalLayer.name + ' (split)';
        
        // Adjust original layer's duration
        originalLayer.duration = cutTime - originalLayer.startTime;

        // Move keyframes that are after the cut to the new layer
        Object.keys(originalLayer.keyframes).forEach(prop => {
            newLayer.keyframes[prop] = originalLayer.keyframes[prop].filter(kf => kf.time >= cutTime);
            originalLayer.keyframes[prop] = originalLayer.keyframes[prop].filter(kf => kf.time < cutTime);
        });

        state.layers.push(newLayer);
        assignLayerToSlot(newLayer, originalLayer.slotId);
        state.layers.sort((a, b) => a.startTime - b.startTime); // Keep timeline sorted
        renderTimeline();
        selectLayer(newLayer.id);
    }

    // --- Properties & Keyframing ---

    function updatePropertiesPanel() {
        if (!state.selectedLayerId) return;
        const layer = state.layers.find(l => l.id === state.selectedLayerId);
        
        // Get current interpolated values
        document.getElementById('prop-x').value = Math.round(layer.getValue('x', state.currentTime));
        document.getElementById('prop-y').value = Math.round(layer.getValue('y', state.currentTime));
        document.getElementById('prop-scale').value = layer.getValue('scale', state.currentTime).toFixed(2);
        document.getElementById('prop-rotation').value = Math.round(layer.getValue('rotation', state.currentTime));
        document.getElementById('prop-opacity').value = layer.getValue('opacity', state.currentTime).toFixed(2);
    }

    function updateProperty(prop, value) {
        if (!state.selectedLayerId) return;
        const layer = state.layers.find(l => l.id === state.selectedLayerId);

        if (layer.keyframes[prop] && layer.keyframes[prop].length > 0) {
            layer.addKeyframe(prop, state.currentTime, value);
        } else {
            layer[prop] = parseFloat(value);
        }
    }

    function addKeyframe(prop) {
        if (!state.selectedLayerId) return;
        const layer = state.layers.find(l => l.id === state.selectedLayerId);
        const val = document.getElementById(`prop-${prop}`).value;
        layer.addKeyframe(prop, state.currentTime, val);
    }

    function addUniversalKeyframe() {
        if (state.selectedLayerId) {
            // Add keyframes for all properties of the selected layer
            const animatableProps = ['x', 'y', 'scale', 'rotation', 'opacity'];
            animatableProps.forEach(prop => {
                addKeyframe(prop);
            });
        } else {
            // No layer selected, add a global zoom keyframe
            addGlobalKeyframe();
        }
    }

    function updateText(val) {
        const layer = state.layers.find(l => l.id === state.selectedLayerId);
        if (layer) { layer.content = val; layer.updateDimensions(); }
    }

    function updateColor(val) {
        const layer = state.layers.find(l => l.id === state.selectedLayerId);
        if (layer) layer.color = val;
    }

    function updateLoopingAnimation(val) {
        if (!state.selectedLayerId) return;
        const layer = state.layers.find(l => l.id === state.selectedLayerId);
        if (layer) {
            layer.loopingAnimation = val;
        }
    }

    // --- Global Zoom & Transform ---

    function getGlobalTransform(time) {
        const kfs = state.globalTransform.keyframes;
        const defaultTransform = { scale: 1, x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2, finalProgress: undefined };

        if (kfs.length === 0) {
            return defaultTransform;
        }

        kfs.sort((a, b) => a.time - b.time);

        if (time <= kfs[0].time) return { ...kfs[0], finalProgress: 0 };
        if (time >= kfs[kfs.length - 1].time) return { ...kfs[kfs.length - 1], finalProgress: 1 };

        let startKf, endKf;
        for (let i = 0; i < kfs.length - 1; i++) {
            if (time >= kfs[i].time && time < kfs[i+1].time) {
                startKf = kfs[i];
                endKf = kfs[i+1];
                break;
            }
        }

        if (!startKf || !endKf) return defaultTransform;

        const { duration, easing, aestheticFps } = state.globalTransform;
        const keyframeDuration = Math.max(0.001, endKf.time - startKf.time);

        const durationOverride = parseFloat(duration);
        const durationInSeconds = durationOverride > 0 ? Math.max(0.001, durationOverride) : keyframeDuration;

        let rawProgress = (time - startKf.time) / durationInSeconds;
        rawProgress = Math.max(0, Math.min(1, rawProgress));

        const fpsValue = parseFloat(aestheticFps);
        if (!Number.isNaN(fpsValue) && fpsValue > 0) {
            const totalFrames = Math.floor(durationInSeconds * fpsValue);
            if (totalFrames > 0 && rawProgress < 1) {
                const currentFrame = Math.floor(rawProgress * totalFrames);
                rawProgress = currentFrame / totalFrames;
            }
        }

        const easingFn = GLOBAL_EASING_FUNCTIONS[easing] || GLOBAL_EASING_FUNCTIONS.linear;
        const finalProgress = easingFn(rawProgress);

        const scale = startKf.scale + (endKf.scale - startKf.scale) * finalProgress;
        const x = startKf.x + (endKf.x - startKf.x) * finalProgress;
        const y = startKf.y + (endKf.y - startKf.y) * finalProgress;

        return { scale, x, y, finalProgress };
    }

    function updateCurrentGlobalTransform(prop, value) {
        state.currentGlobalTransform[prop] = parseFloat(value);
        // If keyframes exist, automatically update/add keyframe at current time
        if (state.globalTransform.keyframes.length > 0) {
            addGlobalKeyframe();
        }
    }

    function addGlobalKeyframe() {
        const time = state.currentTime;
        state.globalTransform.keyframes = state.globalTransform.keyframes.filter(k => Math.abs(k.time - time) > 0.01);
        state.globalTransform.keyframes.push({
            time: time,
            scale: state.currentGlobalTransform.scale,
            x: state.currentGlobalTransform.x,
            y: state.currentGlobalTransform.y,
        });
        state.globalTransform.keyframes.sort((a, b) => a.time - b.time);
        renderGlobalTimeline();
        updateGlobalMotionControlsUI();
    }

    function updateGlobalMotion(prop, value) {
        if (prop === 'aestheticFps') value = parseFloat(value);
        state.globalTransform[prop] = value;
    }

    function updateGlobalMotionControlsUI() {
        const durationInput = document.getElementById('global-duration');
        const fpsInput = document.getElementById('global-fps');
        const easingSelect = document.getElementById('global-easing');

        durationInput.disabled = false;
        fpsInput.disabled = false;
        easingSelect.disabled = false;

        durationInput.value = state.globalTransform.duration;
        durationInput.placeholder = 'auto';
        fpsInput.value = state.globalTransform.aestheticFps;
        easingSelect.value = state.globalTransform.easing;
    }

    function updateGlobalTransformPanel() {
        const transform = getGlobalTransform(state.currentTime);
        document.getElementById('global-prop-scale').value = transform.scale.toFixed(2);
        document.getElementById('global-prop-x').value = Math.round(transform.x);
        document.getElementById('global-prop-y').value = Math.round(transform.y);

        // Sync the staging object
        state.currentGlobalTransform.scale = transform.scale;
        state.currentGlobalTransform.x = transform.x;
        state.currentGlobalTransform.y = transform.y;
    }


    // --- Timeline UI ---

    function renderTimeline() {
        const container = document.getElementById('timeline-tracks');
        // Clear tracks (keep scrubber and playhead)
        container.querySelectorAll('.layer-track').forEach(e => e.remove());

        // Set width based on duration
        const width = state.duration * PIXELS_PER_SECOND;
        renderGlobalTimeline();
        document.getElementById('scrubber').style.width = `${width}px`;

        rebuildSlotAssignments();

        state.layerSlots.forEach((slot, slotIndex) => {
            const track = document.createElement('div');
            track.className = `layer-track ${slot.itemIds.length === 0 ? 'empty' : ''}`;
            track.dataset.slotId = slot.id;
            track.dataset.slotIndex = slotIndex;
            track.style.width = `${width}px`;

            slot.itemIds.forEach(layerId => {
                const layer = state.layers.find(l => l.id === layerId);
                if (!layer) return;

                const block = document.createElement('div');
                block.className = `layer-block ${state.selectedLayerId === layer.id ? 'selected' : ''}`;
                block.innerText = layer.name;
                block.style.left = `${layer.startTime * PIXELS_PER_SECOND}px`;
                block.style.width = `${layer.duration * PIXELS_PER_SECOND}px`;
                block.dataset.layerId = layer.id;

                block.addEventListener('mousedown', (e) => {
                    if (e.target === block) {
                        startTimelineMove(e, layer.id);
                    }
                });

                const handleLeft = document.createElement('div');
                handleLeft.className = 'layer-block-handle left';
                handleLeft.addEventListener('mousedown', (e) => startTimelineResize(e, layer.id, 'left'));

                const handleRight = document.createElement('div');
                handleRight.className = 'layer-block-handle right';
                handleRight.addEventListener('mousedown', (e) => startTimelineResize(e, layer.id, 'right'));

                block.appendChild(handleLeft);
                block.appendChild(handleRight);

                const allKeys = new Set();
                Object.values(layer.keyframes).forEach(kfs => kfs.forEach(k => allKeys.add(k.time)));
                allKeys.forEach(time => {
                    if (time >= layer.startTime && time <= layer.startTime + layer.duration) {
                        const marker = document.createElement('div');
                        marker.className = 'keyframe-marker';
                        marker.style.left = `${(time - layer.startTime) * PIXELS_PER_SECOND}px`;
                        block.appendChild(marker);
                    }
                });

                track.appendChild(block);
            });

            container.appendChild(track);
        });

        const placeholder = document.createElement('div');
        placeholder.className = 'layer-track placeholder';
        placeholder.dataset.slotIndex = state.layerSlots.length;
        placeholder.textContent = 'Drop here to create a new layer';
        placeholder.style.width = `${width}px`;
        container.appendChild(placeholder);

        updateTimelineUI();
    }

    function renderGlobalTimeline() {
        const track = document.getElementById('global-zoom-track');
        if (!track) return;
        track.innerHTML = ''; // Clear
        track.style.width = `${state.duration * PIXELS_PER_SECOND}px`;

        state.globalTransform.keyframes.forEach(kf => {
            const marker = document.createElement('div');
            marker.className = 'keyframe-marker';
            marker.style.left = `${kf.time * PIXELS_PER_SECOND}px`;
            marker.style.top = '5px';
            marker.style.background = 'cyan';
            track.appendChild(marker);
        });
    }
    function updateTimelineUI() {
        const playhead = document.getElementById('playhead');
        const timeDisplay = document.getElementById('time-display');
        
        const pos = state.currentTime * PIXELS_PER_SECOND;
        playhead.style.left = `${pos}px`;
        
        // Format time
        const mins = Math.floor(state.currentTime / 60);
        const secs = Math.floor(state.currentTime % 60);
        const ms = Math.floor((state.currentTime % 1) * 100);
        timeDisplay.innerText = `${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}.${ms.toString().padStart(2,'0')}`;
    }

    // Scrubber interaction
    const scrubber = document.getElementById('scrubber');
    scrubber.addEventListener('mousedown', (e) => {
        const rect = scrubber.getBoundingClientRect();
        const x = e.clientX - rect.left + scrubber.scrollLeft; // Simplified
        // Better to use the container scroll
        const container = document.getElementById('timeline-tracks');
        const offsetX = e.clientX - container.getBoundingClientRect().left + container.scrollLeft;
        
        const time = Math.max(0, offsetX / PIXELS_PER_SECOND);
        state.currentTime = time;
        updateTimelineUI();
        updateAllPanels();
    });

    // --- Drag & Drop File Upload ---
    const body = document.body;
    const dragOverlay = document.getElementById('drag-overlay');

    body.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        dragOverlay.style.display = 'flex';
    });
    body.addEventListener('dragleave', (e) => {
        // Prevent flickering when dragging over child elements
        if (e.relatedTarget === null || !body.contains(e.relatedTarget)) {
            dragOverlay.style.display = 'none';
        }
    });
    body.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        dragOverlay.style.display = 'none';
        
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            for (const file of e.dataTransfer.files) {
                addMediaFile(file);
            }
        }
    });

    // --- Timeline Drag-Resize Logic ---
    function startTimelineResize(e, layerId, handle) {
        e.stopPropagation();
        const layer = state.layers.find(l => l.id === layerId);
        if (!layer) return;

        dragState = {
            active: true,
            type: 'resize-timeline',
            layerId: layerId,
            handle: handle,
            startX: e.clientX,
            initialStartTime: layer.startTime,
            initialDuration: layer.duration
        };

        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
    }

    function startTimelineMove(e, layerId) {
        e.stopPropagation();
        selectLayer(layerId); // Select on click
        const layer = state.layers.find(l => l.id === layerId);
        
        dragState = {
            active: true,
            type: 'move-timeline',
            layerId: layerId,
            startX: e.clientX,
            startY: e.clientY,
            initialStartTime: layer.startTime,
            sourceElement: e.currentTarget // The block element
        };

        const slotIndex = getSlotIndexById(layer.slotId);
        dragState.sourceSlotIndex = slotIndex;
        dragState.targetSlotIndex = slotIndex;
        dragState.sourceSlotId = layer.slotId;
        dragState.timelineContainer = document.getElementById('timeline-tracks');

        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
    }

    function onDrag(e) {
        if (!dragState.active) return;
        e.preventDefault();

        const dx = e.clientX - dragState.startX;
        const dy = e.clientY - dragState.startY;

        // Timeline Logic
        if (dragState.type === 'resize-timeline') {
            const dTime = dx / PIXELS_PER_SECOND;
            const layer = state.layers.find(l => l.id === dragState.layerId);
            if (dragState.handle === 'left') {
                const newDuration = dragState.initialDuration - dTime;
                if (newDuration > 0.1) { layer.startTime = dragState.initialStartTime + dTime; layer.duration = newDuration; }
            } else { // right handle
                const newDuration = dragState.initialDuration + dTime;
                if (newDuration > 0.1) { layer.duration = newDuration; }
            }
            renderTimeline();
            return;
        }

        if (dragState.type === 'move-timeline') {
            // Switch to reordering if drag is mostly vertical
            const tracks = Array.from(document.querySelectorAll('.layer-track'));
            const containerEl = dragState.timelineContainer || document.getElementById('timeline-tracks');
            const timelineRect = containerEl.getBoundingClientRect();
            let targetIndex = tracks.length;
            for (let i = 0; i < tracks.length; i++) {
                const rect = tracks[i].getBoundingClientRect();
                if (e.clientY < rect.top + rect.height / 2) {
                    targetIndex = i;
                    break;
                }
            }
            dragState.targetSlotIndex = targetIndex;

            if (!dragState.isReordering && Math.abs(dy) > 15 && Math.abs(dy) > Math.abs(dx)) {
                dragState.isReordering = true;
                dragState.sourceElement.classList.add('dragging-source');
                document.getElementById('drop-indicator').style.display = 'block';
            }

            if (dragState.isReordering) {
                const indicator = document.getElementById('drop-indicator');
                let indicatorTop = 0;
                if (tracks.length === 0) {
                    indicatorTop = 0;
                } else if (targetIndex === tracks.length) {
                    const lastRect = tracks[tracks.length - 1].getBoundingClientRect();
                    indicatorTop = lastRect.bottom - timelineRect.top;
                } else {
                    const targetRect = tracks[targetIndex].getBoundingClientRect();
                    indicatorTop = targetRect.top - timelineRect.top;
                }
                indicator.style.top = `${Math.max(0, indicatorTop)}px`;
                indicator.style.display = 'block';
            } else {
                const dTime = dx / PIXELS_PER_SECOND;
                const layer = state.layers.find(l => l.id === dragState.layerId);
                layer.startTime = Math.max(0, dragState.initialStartTime + dTime);
                renderTimeline();
            }
            return;
        }

        // Canvas Logic
        if (dragState.type.startsWith('canvas-')) {
            handleCanvasDrag(e);
            updateAllPanels();
        }
    }

    function stopDrag() {
        if (dragState.targetSlotIndex >= 0) {
            const layer = state.layers.find(l => l.id === dragState.layerId);
            if (layer) {
                const slotCount = Math.max(state.layerSlots.length, 1);
                let targetIndex = Math.min(Math.max(0, dragState.targetSlotIndex), slotCount);
                let slot;
                if (targetIndex >= state.layerSlots.length) {
                    slot = createLayerSlot(null, state.layerSlots.length);
                } else {
                    slot = state.layerSlots[targetIndex];
                }
                assignLayerToSlot(layer, slot.id);
                renderTimeline();
            }
        }
        if (dragState.type && dragState.type.startsWith('canvas-')) {
            renderTimeline();
        }
        document.getElementById('drop-indicator').style.display = 'none';
        if (dragState.sourceElement) {
            dragState.sourceElement.classList.remove('dragging-source');
        }

        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
        dragState.active = false;
        dragState.targetSlotIndex = -1;
        dragState.isReordering = false;
    }

    // --- Canvas Interaction ---

    function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    function handleCanvasMouseDown(e) {
        const pos = getPointerPos(e);
        
        // Check if clicking on controls of selected layer
        if (state.selectedLayerId) {
            const layer = state.layers.find(l => l.id === state.selectedLayerId);
            // Simple distance check for rotation handle (approximate)
            // We need to transform the mouse pos into layer space to check bounds accurately
            // For MVP, let's just check if we clicked the layer body for drag
            // And check corners for scale?
            
            // Let's do a simple hit test for the layer body first
            // Inverse transform is hard without a matrix library, let's approximate
            // or just iterate layers for selection
        }

        // Hit test layers top to bottom
        const reversedLayers = [...state.layers].reverse();
        let hitLayer = null;
        let hitType = 'canvas-drag';

        for (const layer of reversedLayers) {
            if (state.currentTime < layer.startTime || state.currentTime > layer.startTime + layer.duration) continue;
            
            // Transform point to layer local space
            // 1. Translate -x, -y
            // 2. Rotate -deg
            // 3. Scale 1/s
            const dx = pos.x - layer.getValue('x', state.currentTime);
            const dy = pos.y - layer.getValue('y', state.currentTime);
            const r = -layer.getValue('rotation', state.currentTime) * Math.PI / 180;
            const s = 1 / layer.getValue('scale', state.currentTime);
            
            const localX = (dx * Math.cos(r) - dy * Math.sin(r)) * s;
            const localY = (dx * Math.sin(r) + dy * Math.cos(r)) * s;

            const w = layer.width || 100;
            const h = layer.height || 100;

            // Check Rotation Handle (Top)
            // Handle pos: (0, -h/2 - 50/s)
            // Hit radius: 20/s
            const rotX = 0;
            const rotY = -h/2 - 50/s;
            const distRot = Math.sqrt((localX - rotX)**2 + (localY - rotY)**2);
            
            if (distRot <= 20/s) {
                hitLayer = layer;
                hitType = 'canvas-rotate';
                break;
            }

            // Check Scale Handles (Corners)
            // Corners: +/- w/2, +/- h/2
            // Hit radius: 20/s
            const corners = [
                {x: -w/2, y: -h/2}, {x: w/2, y: -h/2},
                {x: w/2, y: h/2}, {x: -w/2, y: h/2}
            ];
            const hitCorner = corners.some(c => Math.sqrt((localX - c.x)**2 + (localY - c.y)**2) <= 20/s);
            
            if (hitCorner) {
                hitLayer = layer;
                hitType = 'canvas-scale';
                break;
            }
            
            // Check Body
            if (localX >= -w/2 && localX <= w/2 && localY >= -h/2 && localY <= h/2) {
                hitLayer = layer;
                hitType = 'canvas-drag';
                break;
            }
        }

        if (hitLayer) {
            selectLayer(hitLayer.id);
            dragState = {
                active: true,
                type: hitType,
                layerId: hitLayer.id,
                startX: pos.x,
                startY: pos.y,
                initialX: hitLayer.getValue('x', state.currentTime),
                initialY: hitLayer.getValue('y', state.currentTime),
                initialRotation: hitLayer.getValue('rotation', state.currentTime),
                initialScale: hitLayer.getValue('scale', state.currentTime),
                // For rotation/scale calculations
                initialAngle: Math.atan2(pos.y - hitLayer.getValue('y', state.currentTime), pos.x - hitLayer.getValue('x', state.currentTime)),
                initialDist: Math.sqrt((pos.x - hitLayer.getValue('x', state.currentTime))**2 + (pos.y - hitLayer.getValue('y', state.currentTime))**2)
            };
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
        } else {
            selectLayer(null);
        }
    }

    function handleCanvasMouseMove(e) {
        // Cursor updates could go here
    }

    function handleCanvasMouseUp(e) {
        // Handled by global stopDrag usually
    }

    function handleCanvasDrag(e) {
        const pos = getPointerPos(e);
        const layer = state.layers.find(l => l.id === dragState.layerId);
        
        const setVal = (prop, val) => {
            if (layer.keyframes[prop] && layer.keyframes[prop].length > 0) {
                layer.updateOrAddKeyframe(prop, state.currentTime, val);
            } else {
                layer[prop] = val;
            }
        };

        if (dragState.type === 'canvas-drag') {
            const dx = pos.x - dragState.startX;
            const dy = pos.y - dragState.startY;
            
            setVal('x', dragState.initialX + dx);
            setVal('y', dragState.initialY + dy);
        }
        else if (dragState.type === 'canvas-rotate') {
            // Calculate new angle
            const lx = layer.getValue('x', state.currentTime);
            const ly = layer.getValue('y', state.currentTime);
            const currentAngle = Math.atan2(pos.y - ly, pos.x - lx);
            const dAngle = currentAngle - dragState.initialAngle;
            // Convert to degrees
            setVal('rotation', dragState.initialRotation + (dAngle * 180 / Math.PI));
        }
        else if (dragState.type === 'canvas-scale') {
            // Calculate new distance
            const lx = layer.getValue('x', state.currentTime);
            const ly = layer.getValue('y', state.currentTime);
            const currentDist = Math.sqrt((pos.x - lx)**2 + (pos.y - ly)**2);
            // Scale ratio
            const scaleRatio = currentDist / dragState.initialDist;
            setVal('scale', dragState.initialScale * scaleRatio);
        }
    }

    // --- Playback Controls ---

    document.getElementById('btn-play').onclick = () => {
        state.isPlaying = !state.isPlaying;
        updatePlayButton();
    };

    document.getElementById('btn-stop').onclick = () => {
        state.isPlaying = false;
        state.currentTime = 0;
        updatePlayButton();
        updateTimelineUI();
        updateAllPanels();
    };

    function updatePlayButton() {
        document.getElementById('btn-play').innerText = state.isPlaying ? 'Pause' : 'Play';
    }

    // --- Export Logic ---

    const captureCanvasWithMediaRecorder = (progressCallback) => new Promise((resolve, reject) => {
        if (!canvas.captureStream || typeof MediaRecorder === 'undefined') {
            reject(new Error('MediaRecorder captureStream is not supported in this browser'));
            return;
        }

        const stream = canvas.captureStream(FPS);
        const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' });
        const chunks = [];
        let frame = 0;
        const totalFrames = Math.max(1, Math.round(state.duration * FPS));
        const intervalMs = 1000 / FPS;
        let frameInterval;

        recorder.ondataavailable = (event) => {
            if (event.data && event.data.size) {
                chunks.push(event.data);
            }
        };
        recorder.onerror = (event) => {
            clearInterval(frameInterval);
            stream.getTracks().forEach(track => track.stop());
            reject(event.error || new Error('MediaRecorder error'));
        };
        recorder.onstop = () => {
            stream.getTracks().forEach(track => track.stop());
            resolve(new Blob(chunks, { type: 'video/webm' }));
        };

        frameInterval = setInterval(() => {
            if (frame >= totalFrames) {
                clearInterval(frameInterval);
                state.currentTime = state.duration;
                renderCanvas();
                updateTimelineUI(); // These are needed to show the final state before stopping
                updateAllPanels();
                if (progressCallback) progressCallback(1);
                recorder.stop();
                return;
            }
            state.currentTime = frame / FPS;
            renderCanvas(); // This now includes global transform
            updateTimelineUI();
            updatePropertiesPanel();
            if (progressCallback) progressCallback(Math.min(1, frame / totalFrames));
            frame += 1;
        }, intervalMs);

        recorder.start();
    });

    document.getElementById('btn-export').onclick = async () => {
        const overlay = document.getElementById('export-overlay');
        const progress = document.getElementById('export-progress');
        const exportButton = document.getElementById('btn-export');
        const exportStatus = overlay.querySelector('h2');

        exportButton.disabled = true;
        exportButton.innerText = 'Preparing...';
        exportStatus.innerText = 'Preparing Export...';
        overlay.style.display = 'flex';
        progress.style.width = '0%';

        state.isPlaying = false;
        state.currentTime = 0;
        cancelAnimationFrame(animationFrameId); // Stop main loop interaction

        let ffmpeg;
        let exportBlob;
        const useFFmpeg = typeof SharedArrayBuffer !== 'undefined' && window.crossOriginIsolated;

        try {
            if (!useFFmpeg) {
                exportStatus.innerText = 'Using MediaRecorder fallback (no SharedArrayBuffer)';
                progress.style.width = '0%';
                exportBlob = await captureCanvasWithMediaRecorder((ratio) => {
                    progress.style.width = `${ratio * 100}%`;
                });
            } else {
                const { createFFmpeg, fetchFile } = FFmpeg;
                const FFCORE_CDN = 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.11.0/dist';
                ffmpeg = createFFmpeg({ 
                    log: true,
                    corePath: `${FFCORE_CDN}/ffmpeg-core.js`,
                    workerPath: `${FFCORE_CDN}/ffmpeg-core.worker.js`,
                    wasmPath: `${FFCORE_CDN}/ffmpeg-core.wasm`
                });
                    
                exportStatus.innerText = 'Loading FFMPEG Core (~30MB)...';
                await ffmpeg.load();

                exportStatus.innerText = 'Rendering Frames...';

                const totalFrames = Math.round(state.duration * FPS);
                for (let i = 0; i < totalFrames; i++) {
                    state.currentTime = i / FPS;
                    renderCanvas();
                    
                    const frameNumber = String(i).padStart(5, '0');
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    ffmpeg.FS('writeFile', `frame-${frameNumber}.png`, await fetchFile(blob));

                    progress.style.width = `${((i + 1) / totalFrames) * 50}%`; // 0-50% for rendering
                }

                exportStatus.innerText = 'Encoding MP4...';
                
                progress.style.width = '50%';
                ffmpeg.setProgress(({ ratio }) => {
                    progress.style.width = `${50 + ratio * 50}%`;
                });

                await ffmpeg.run(
                    '-framerate', String(FPS), 
                    '-i', 'frame-%05d.png', 
                    '-c:v', 'libx264', 
                    '-pix_fmt', 'yuv420p', 
                    '-crf', '18', 
                    'output.mp4'
                );

                const data = ffmpeg.FS('readFile', 'output.mp4');
                exportBlob = new Blob([data.buffer], { type: 'video/mp4' });
            }

            const downloadUrl = URL.createObjectURL(exportBlob);
            const a = document.createElement('a');
            a.href = downloadUrl;
            a.download = useFFmpeg ? 'shorts-export.mp4' : 'shorts-export.webm';
            a.click();
            URL.revokeObjectURL(downloadUrl);

        } catch (error) {
            console.error(error);
            alert('An error occurred during export. Check the console for details.');
        } finally {
            if (ffmpeg) {
                try {
                    await ffmpeg.exit();
                } catch (exitError) {
                    console.warn('FFmpeg cleanup failed', exitError);
                }
            }
            // Cleanup and reset UI
            overlay.style.display = 'none';
            exportButton.disabled = false;
            exportButton.innerText = 'Export Video';
            state.currentTime = 0;
            renderCanvas(); // Show first frame
            updateTimelineUI();
            updateAllPanels();
            animationFrameId = requestAnimationFrame(gameLoop); // Restart main loop
        }

    };

    // Initialize
    // Add global listeners for drag operations
    document.addEventListener('mouseup', () => {
        if (dragState.active) {
            stopDrag();
        }
    });
    init();

</script>
</body>
</html>
